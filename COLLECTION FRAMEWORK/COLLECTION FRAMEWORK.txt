-------------------------------------------------------------- COLLECTION FRAMEWORK ---------------------------------------------------
An array is an indexed collection fixed number of homogeneous data elements. 
The main advantage of array is we can represent multiple value by using single variable so that readability of the code will be improved.

**** Limitation of array
	- Array are fixed in size i.e. once we create an array there is no chance of increasing and decreeing on size base on our requirement due to this we used array concept complsure we should known the size in advance which may not possible always.
	- Array can hold homogeneous data type elements.
	EX - Student [] s = new Student[1000];
		s[0] = new Student();
		s[1] = new Customer(); ---> Error incompatible types found: Customer required: Student
	- We can solve this problem by using object type array.
	EX - Object [] a = new Object[10000]
		a[0] = new Student();
		a[1] = new Customer();
	- Array concept is not implemented based on some standard data structure and hence ready-mate support is not available for every requirement we have to write the code explicitly which increase complexity of programming.
	- To overcome the above problems of array we should go for COLLECTION CONCEPT.
	
**** Collection 
	- Collection are Growable in nature i.e. based on our requirement we increase and decrease the size
	- Collection can hold both Homogeneous and Heterogenous object
	- Every collection class is implemented based on some standard data structure hence for every requirement ready-meta method support is available.
	- begin a programmer we are responsible to used those method we are not responsible to implement those method.

**** Difference between Array and Collection
Array 
	- Array are fixed in size i.e. once we create an array we can't increase and decrease size based on our requirement 
	- With respect to memory array are not recommended to use.	
	- With respect to performance array are recommended to use.
	- Array can hold only Homogeneous data type elements.
	- there is no under line data structure for array and hence ready-mate support is not available.
	- For every requirement we have write the code which increases complexity of programming.\
	- Array can hold both primitive and object

Collection 
	- Collection are growable in nature i.e. based on our requirement we can increase and decrease the size.
	- With respect to memory collection are  recommended to use.
	- With respect to performance Collection are not recommended to use.
	- Collection can hold both Homogeneous and Heterogeneous data type elements.
	- Every collection class is implemented based on some standard data structure and hence for every requirement ready-mate method support is available begin a programmer we can use this method directly and we not responsible to implement those method.
	- Collection can hold only object type but not primitive.

**** Collection 
	- If we want to represent a group of individual element as single entity then we should go for collection.

**** Collection Framework
	- It contains several classes and interface which can be used to represent a group of individual element as single entity.

NOTE -  Interface are giving all the information about program or machine or code.
	Class is a nothing but dummy template to create Interface.

**** 9 Key Interfaces of Collection Framework
	1 - COLLECTION 
	2 - List
	3 - Set
	4 - SortedSet
	5 - NavigableSet
	6 - Queue 
	7 - Map  
	8 - SortedMap
	9 - NavigableMap

***** 1 - COLLECTION (I)
	- If you want to represent a group of individual object as a single entity then we should go for collection.
	- Collection interface define the most common method which are applicable for any collection object.
	- In general Collection interface is consider as root interface of collection framework.
	- There is no conceit class which implement collection interface directly.
	
**** Difference between Collection and Collections
	- Collection is an interface
	- If you want to represent a group of individual object as a single entity then we should go for collection.
	- Collections is an utilit class present in java.util package to define several utilit method for collection object (like sorting searching etc...).
	
***** 2 - List(I)
	- Which is the child interface of collection.
	- If you want to represent a group of individual object as single entity where "duplicate are allow" and "insertion order most be preserved" then we should go for List.
	
	Diagram (Note - Duplicate are allow and Insertion order most be preserved (Means what ever you enter value as it is stored))

	NOTE - in 1.2v vector and stack classes are Re-engined Error to implement List interface

***** 3- Set
	- It is the child interface of collection 
	- If you want to represent a group of individual object as single entity where "duplicate are not allowed" and "insertion order not required" then we should go for set interface.
	
	Diagram (Note - Duplicate are not allowed and Insertion order not required (Means sorted))

***** 4- SortedSet (I)
	- It is the child interface of Set
	- If you want to represent a group of individual object as a single entity where "Duplicate are not allowed " and all Object are should be sorted in some sorting order the we go for sorted sort. 

	Diagram (Note - Duplicate are not allow and Object are should be sorted in some sorting order)

***** 5- NavigableSet (I)
	- It is the child interface of SortedSet
	- It contains several method for navigation purposes.

**** Difference between List and Set
	*** List
		- Duplicate are allowed
		- Insertion order preserved

	*** Set 
		- Duplicate are not allowed
		- Insertion not preserved

***** 6 - Queue (I)
	- it is the child interface of collection.
	- If you want to represent a group of individu8al object priory to processing then we should go for queue.
	- Usually queue follow FIFO order but based on our order we can implement our own priority order
	- EX - Before sending a mail all mail id we have to stored in some data structure , in which order we added mail id in the same order only mail should be delivery for this requirement queue is best choices.

	NOTE - All the above interface (Collection,List,SortedSet,Set,NavigableSet,Queue) maint for representing a group of individual object
		 -If you want represent a group of object as Key-value Pair then we should go for "MAP".

***** 7 - Map (I)
	- Map is "not clid of Interface".
	- If you want to represent a group of object are Key-value Pair then we should go for MAP.
	- Both key and value are object only.
	- Duplicate keys are not allowed but value can be duplicated 
	Diagram (Note - key are not duplicate but value are duplicate (key and value both are object))

***** 8 - SortedMap (I)
	- It is the clid interface of MAP.
	- If you want to represent a group  of key value pair according to some "sorting order of keys" then we should go for SortedMap.
	- In SortedMap the sorting should be based on key but not based on value.

***** 9 - NavigableMap (I)
	- It is the clid interface of SortedMap.
	-It define several methods for navigation purposes.
	
	NOTE - the following are Legacy Character present in collection Framework
		1) Enumeration (Interface)
		2) 2Dictionary(Abstract Class)
		3) Vector(Class)
		4) Stack(Class)
		5) HashtabIe(Class)
		6) Properties(Class) 

Collection (I)
===========
	- If you want to represent a group of individual object as a single entity then we should go for collection.
	- Collection interface define the most common method which are applicable for any collection object 

	ALL method
	-----------
		- boolean add(Object o)
		- boolean addAll(CoIlection c)
		- boolean remove(Object o)
		- boolean removeAII(Collection c)
		- boolean retainAll(Collection c)
		- To rernove all objects except those
		- present in c
		- void clear()
		- boolean contains(Object o)
		- boolean containsAll(Collection c)
		- boolean isEmpty()
		- int size();
		- Objectu toArray();
		- Iterator iterator()
	
		NOTE - there is no conceit class which implement collection interface directly

List (I)
=========
	- List is child interface of collection.
	- If we want to represent a group of individual object as a single entity where duplicate are allowed and insertion order most be preserved then we should go for List
	- we can preserved insertion order with index and we can differentiate duplicate object by using index, hence index will play very important role in List.

	**** method are
	----------------
		1) void add(int index,Object o)
		2) boolean addAll(int index,Coltection c)
		3) Object Gl(int index)
		4) Object remove(int index)
		5) Object set(int index, Object new)
				- to replace the element present at specified index with provided Object and returns old object
		6) int indexOf(Object o)
				- returns index of first occurrence of 'o'
		7) int lastlndexOf(Object o)
		8) Listlterator listlterator();

	- Type of List is
	-----------------
		1) ArrayList
		1) LinkedList
		1) vector
		4) Stack

1) ArrayList
-------------
	- The underline data structure is resizeble array of growable array.
	- Duplicate are allowed.
	- Insertion order is preserved.
	- Heterogeneous object are allowed (except TreeSet and TreeMap every where Heterogeneous object are allowed).
	- Null insertion is possible 
	
	**** Constructor
	----------------
		ArrayList l = new ArrayList();
			- create an empty ArrayList object with the default initial capacity 10.
			- Once ArrayList reaches max capacity then a new ArrayList object will be created with " new capacity = (Current Capacity * 3/2)+1 "

		ArrayList l = new ArrayList(int initialCapacity);
			- Create an empty array list object with specified initial capacity.

		ArrayList l = new ArrayList(Collection c);
			- Create an equvalent array list object for the given collection.

	- Usually we can use collection to hold and transfer object from one location to another location (container) to provid support for this requirement every collection class by-default implement sirializeble and clonable object.
	- ArrayList and Vector classes implement Random Access Interface so that any Random element we can Access with the same speed.

	NOTE - If required "Fast fetching then we should go ArrayList".

	**** Random Access
	------------------
		- Random Access interface present in java.util package and it does not contain any method and it is a maerker Interface, where required ability will be provided automaticlly by the "JVM".
		- ArrayList is the best choices if our frequent operation is retrieval operation (Because array implement Random Access Interface)
		- ArrayList is the worst choices if our frequent operation is "insertion and Deletion in the middle".

***** Difference between ArrayList and Vector
-------------------------------------------
	**** ArrayList
		- Every method present in the ArrayList is non-Syncronized 
		- At a time multiple thread are allowed to operate on ArrayList object and hence it is not thread safe.
		- Relatively performance is High Because thread are not required to wait to operate on ArrayList object.
		- Introduced in 1.2v and it is non Legacy.
 
	**** Vector
		- Every method present in the Vector is Syncronized.
		- At a time only one thread to operate on vector object and hence it is thread safe. 
		- Relatively performance is low because thread are required to wait to operate on vector object.
		- Introduced in 1.0v and it is Legacy.


***** How to get Syncronized version of ArrayList object
---------------------------------------------------------
	- By default ArrayList is non-Synchronized but we can get Syncronized version of ArrayList object by using "SyncronizedList()" of "Collections Class".
	- Method (public static List SyncronizedList(List l));
	- ex -  ArrayList l = new ArrayList();
		   List l1 = Collections.SyncronizedList(l);
		   here --> l is non-Syncronized
		   			l1 is Synchronized
	- Similarly we can get Synchronized version of set and map object by using the following methods of Collections class 
		--> public static Set synchronizedSet(Set s)
		--> public static Map synchronizedMap(Map m)


***** LinkedList
------------------
	- The underline LinkedList double LinkedList or doubly LinkedList
	- Insertion order is preserved.
	- Duplicate object are allowed.
	- Heterogeneous object are allowed.
	- Null insertion is possible.
	- LinkedList implements serializable and cloneable interface but not Random Access.
	- LinkedList is the best choice if our frequent operation is insertion and Deletion in the middle.
	- LinkedList is the worst choice if our frequent operation is retrieval operation.

	**** Constructor
	----------------
		LinkedList l = new LinkedList();
			- Create an empty LinkedList object 

		LinkedList l = new LinkedList(Collection c);
			- Create an equivalent LinkedList object for the given collection

	**** LinkedList class specified Method
		 	-Usually we can use LinkedList to developed stack and Queue to provide support for this requirement LinkedList class defines that following specific methods.
			1) void addFirst(Object o)
			2) void addLast(Object)
			3) Object getFirst()
			4) Object getLast()
			5) Object removeFirst()
			6) Object removeLast()


***** Difference between ArrayList and LinkedList
-------------------------------------------------
	ArrayList
		- ArrayList is the best choice if our frequent operation is "Retrival Operation"
		- ArrayList worst choice if our frequent operation is "Insertion and Deletion in middle" because internally several shift operation are performed.
		- In ArrayList the element will stored the conjucate memory location and hence retrieval operation is easy.
 
	LinkedList
		- LinkedList is the best choice if our frequent operation "Insertion and Deletion in middle"
		- LinkedList worst choice if our frequent operation is "Retrival Operation".
		- In LinkedList the elements want to be stored in the conjucative memory locations and hence retrieval operation will become complex.

***** Vector
--------------
	- The underline data structure is resizeble array and growable array.
	- Insertion order is preserved .
	- Duplicate are allowed .
	- Heterogeneous object are allowed.
	- NULL insertion is possible.
	- It implements serializable , clonable and Random Access interface.
	- Every Method present in the vector is Synchronized and hence vector object is "Thread safe".

	**** Constructor
	----------------
		Vector v = new Vector();
			- Creates an empty vector object with default initial capacity 10;
			- Once vector reaches it's MAX capacity then a new vector object will be created with " new Capacity = Current Capacity * 2 ".
 
		Vector v = new Vector(int initialCapacity);
			- Creates an empty vector object with specified initial capacity.
		 
		Vector v = new Vector(int initialCapacity, int incrementalCapacity);
			- After reaching a initialCapacity then memory will be increase according to "incrementalCapacity". Means if initialCapacity is 1000 and  incrementalCapacity is 5 then After across 1000 then memory will be like 1005 , 1010 , 1015 so on.
 
		Vector v = new Vector(Collection c);
			- Creates an equvalent vector object for the given collection.
			- This Constructor maint for interconversion between collection object.

		ALL method
		-----------
			To Add-------------------
			- add(Object o) ----C
			- add(int index,Object o)-----L
			- addEIement(Object o)------V

			To Remove ---------------
			- rernove(Objec o)------C
			- rernoveElement(Object o)------V
			- rernove(int index)-----L
			- rernoveElementAt(int index)----V
			- clear()
			- rernoveAllElements()------V

			To Get Object--------------------
			- Object get(int index)-------L
			- Object elementAt(int index)-----V
			- Object firstElement() ----V
			- Object lastElement() ----V

			Others---------------------------
			- int size()
			- int capacity()
			- Enumeration elements()

***** Stack
--------------
	-It is the child class of vector.
	-It is a special design class for LAST IN FAST OUT "LIFO".

	**** Constructor
	----------------
		Stack S = new Stack();

	ALL method
	-----------
		Object push (Object o)
			- to insert an object into the stack
		Object pop()
			- to remove and return top of the stack
		Object peek()
			- to return top of the stack without removal
		boolean empty()
			- returns true if the stack is empty
		int search(Object o)
			- returns offset if the element is available otherwise returns -1

	NOTE - Diagram here 

***** The 3 Cursors of java
-----------------------------
	-If we want get object one by one from the collection then we should go for Cursors.
	-There are 3 types of cursors available in java.
		1- Enumeration
		2- Iterator
		3- ListIterator
		
1- Enumeration
---------------
	- We can use Enumeration to get object one by one from Legacy collection object.
	- We can create Enumeration object by using element method of Vector class
	- public Enumeration element();
	EX - Enumeration e = v.elements(); (here v = vector object)

	ALL Method
	----------
		- public boolean hasMoreElements();
		- public Object nextElement();

	Limitation Of Enumeration
	--------------------------
		- We can apply Enumeration concept only for Legacy classes And it not a universal cursor.
		- by using Enumeration we can get only Read Access and we can't performed remove operation.
		- To overcome above Limitation we should go for "Iterator".

2- Iterator
------------
	- we can apply Iterator concept for any collection object and hence it is universal cursor.
	- By using Iterator we can performe both Read and Remove Operation.
	- We can create Iterator object by using Iterator method of collection interface.
	- public Iterator iterator();
	EX - Iterator itr = c.iterator(); (Here c = any collection object)

	ALL Method
	----------
		- public boolean hasNext();
		- public Object next();
		- public void remove();

	Limitation Of Iterator
	--------------------------
		- y using Enumeration and Iterator we can always move only towardas forward direction and we can't move to wards backwordas direction, These are single direction cursors but not bideriactional cursor.
		- By using Iterator we can performe only read and remove operations and we can't performe replacement and insert of new object.
		- To overcome above Limitation we should go for "ListIterator".

3- ListIterator
----------------		
	- By using ListIterator we can move aeither to the forward direction or to the backword direction and hence it is bideriactional cursor.
	- By using ListIterator we can performe replacement and addition of new Object in addition to read and remove operations.
	- we can create ListIterator by using listIterator() of ListInterface.
	- public ListIterator listIterator();
	EX - ListIterator ltr = l.listIterator(); (Here l = any List object)

	ALL Method
	----------
		- ListIterator is the child interface of Iterator and hence all method present in Iterator. by default available to the List Iterator
		-ListIterator it find the 9 method 
		For Forward Movement----------------------
		- public boolean hasNext();
		- public Object next();
		- public int nextIndex();

		For Backward Movement----------------------
		- public boolean hasPrevious();
		- public Object previous();
		- public int previousIndex();
		
		For Forward Movement----------------------
		- public void remove();
		- public void add();
		- public void set();
	
	NOTE - The most powerful cursor is "ListIterator" but it's limitation is it applicable only for "LIST OBJECT".

***** Comparison table of 3 Cursors
------------------------------------
Property
-------------
1- Where we can apply ?
2- It's Legacy ?
3- Movement ?
4- Allowed operations ?
5- How we can get ?
6- Method ?

1- Enumeration
---------------------------------------
	- Only for Legacy class.
	- Yes (1.0v).
	- single direction (Only forward direction).
	- Only Read.
	- By using elements() of vector class.
	- 2 method.
		hasMoreElements();
		nextElement();

2- Iterator
---------------------------------------------
	- For any collection object.
	- No (1.2v).
	- single direction (Only forward direction).
	- Read and Remove.
	- By using iterator() of Collection Interface.
	- 3 method.
		hasNext();
		next();
		remove();

3- ListIterator
-----------------------------------------------
	- Only for List objects.
	- No (1.2v).
	- bi-direction (both direction forward and backword).
	- Read or Remove or Replace or Add.
	- By using listIterator() of List interface.
	- 9 method.
		hasNext();
		next();
		nextIndex();
		hasPrevious();
		previous();
		previousIndex();
		remove();
		add();
		set();

Internal Implementation of Cursors
-----------------------------------
	Vector v = new Vector();
        Enumeration e = v.elements();
        System.out.println(e.getClass().getName()); // java.util.Vector$1

        Iterator i = v.iterator();
        System.out.println(i.getClass().getName()); // java.util.Vector$Itr

        ListIterator l = v.listIterator();
        System.out.println(l.getClass().getName()); // java.util.Vector$ListItr

//        Note  ==> before $ means Outer Class
//              ==> after $ means inner Class
//              ==> and 1 means anonymous block or class



***** Set (I)
---------------
	-Set is child interface of collection.
	-If we want represent a group of individual object as a single entity where duplicate are not allowed and insertion order not preserved.
	-Set interface does not contain any new method and we have use only collection interface methods.

**** HashSet
--------------
	-The underline data structur is "HashTable".
	-Duplicate object are not allowed.
	-Insertion order is not preserved and it is based on hashcode of object .
	-Null insert possible.(only once).
	-Heterogeneous Object are allowed.
	-Implement serializable and clonable but not Random Access interface.
	-HashSet is best choice if our frequent operation is "Search".

	NOTE - In HashSet duplicate are not allowed if you are trying to insert duplicate then we want get any compile time or run time error and add method simple return false.
		-EX = HashSet h = new HashSet();
					  h.add("A");
					  h.add("A"); ------------------> return false
	
	**** Constructor
	----------------
		HashSet h = new HashSet();
			-Create an empty HashSet object with default initial capacity "16" and default "Fill Ratio : 0.75".
		
		HashSet h = new HashSet(int initialCapacity);
			-Creates an empty HashSet Object with specified initial capacity and default "fill Ratio : 0.75".
		
		HashSet h = new HashSet(int initialCapacity, float fillRatio);
			-Creates an empty HashSet Object with specified initial capacity and specified fill Ratio .

		HashSet h = new HashSet(CoIlection c);
			-Create an equivalent hashset for the given collection.
			-This Constructor meant for interconversion between collection objects.

***** Fill Ratio OR Load Factor
--------------------------------
	-After filling how much Ratio a new HashSet object will be created, This Ratio is called fill Ratio or load Factor.
	EX = Fill Ratio : 0.75 Means after filling 75% Ratio a new HashSet object will be created.

***** LinkedHashSet
---------------------
	- It is the child class of HashSet.
	- It is exactly same as HashSet (including Constructor on methods) except the following Difference.

Difference between HashSet and LinkedHashSet
----------------------------------------------
	HashSet
	----------------
		- the underline data structure is HashTable.
		- Insertion order not preserved.
		- Introduced in 1.2v.

	LinkedHashSet
	---------------
		- underline data structure is combination of LinkedList + Hashtable
		- Insertion order preserved.
		- Introduced in 1.4v.

	- In the above program if we replace HashSet with LinkedHashSet then the out is "[D, A, C, B, null, 10]". (go to code folder and see it)
	- i.e. insertion order preserved.

	NOTE - In general we can used LinkedHashSet to developed "cache based application" where duplicate are not allowed and insertion order preserved.

***** SortedSet
-----------------
	-SortedSet is the child interface of Set.
	-If we want to represent a group of individual object according to some sorting order without duplicate then we should go for SortedSet.
	-SortedSet interface defines the following specific methods 

	ALL method
	-----------
		Object first();
			- returns first element of the SortedSet.
		Object last();
			- returns last element of the SortedSet.
		SortedSet headSet(Object obj)
			- returns SortedSet elements are less than obj.
		SortedSet tailSet(Object obj)
			- returns SortedSet whose elements are >= obj
		SortedSet subSet(Object obj1,Object obj2)
			- returns SortedSet whose elements are >= obj1 and < obj2
		Comparator comparator( )
			- returns Comparator object that describes underlying sorting technique. If we are using default natural sorting order then we will get null.

	NOTE - The default natural sorting order for "Numbers : Ascending order" and for "String object : Alphabetic order".

	EX = > SortedSet : [100, 101, 104, 106, 110, 115, 120]
			- Object first(); --------------> 100
			- Object last(); --------------> 120
			- SortedSet headSet(106) ----------> [100, 101, 104]
			- SortedSet tailSet(106) ---------> [106, 110, 115, 120]
			- SortedSet subSet(101,115) -------> [101, 104, 106, 110]
			- Comparator comparator() -------> (If default sort then it gives null)
		
***** TreeSet
---------------
	-The underline data structur is balanced Tree.
	-Duplicate object are not allowed.
	-Insertion order not preserved.
	-Heterogeneous Object are not allowed otherwise we will get run time exception saying "class cast Exception".
	-Null insertion possible (only once).
	-TreeSet implement serializable and clonable but not Random Access.
	-All object will inserted best on some sorting order , it may be default natural sorting order or customizer sorting order.

	**** Constructor
	----------------
		TreeSet t = new TreeSet();
			- Create an empty TreeSet object where the element will be inserted according to "default natural sorting order"
			
		TreeSet t = new TreeSet(Comparator c);
			- Create an empty TreeSet object where the element will be inserted according to customized sorting order specified by comparator object.

		TreeSet t = new TreeSet(Collection c);

		TreeSet t = new TreeSet(SortedSet s);

***** Null Acceptance 
----------------------
	1-For non empty TreeSet if you are trying to insert null then we will get NullPointerException.
	2-For empty TreeSet as the 1st element null is allowed but after inserting that null if you are trying to insert Other then we will get run time exception saying NullPointerException

	NOTE - until 1.6v Null is allowed at 1st element to the empty TreeSet but from 1.7v ownword Null is not allowed even as the first element.[Null Such type  of story not applicable for TreeSet 1.7v ownword]. 

	-If you are depending default natural sorting order complsure the object should be homogeneous and comparable otherwise we will get run time Exception saying "ClassCastException".
	-An object is said to be comparable if and only if corresponding class implement "Comparable Interface".
	-String Class and all wrapper classes already implement comparable interface but StringBuffer Class does not implement Comparable interface hence we got "ClassCastException". Bellow Example --
		TreeSet t = new TreeSet();
        t.add(new StringBuffer("A"));
        t.add(new StringBuffer("Z"));
        t.add(new StringBuffer("B"));
        t.add(new StringBuffer("L"));
        System.out.println(t); // [A, B, L, Z] // Before 1.6v it will gives error(ClassCastException).


***** Comparable Interface (I)
-------------------------------
	-It is present in "Java.lang package" and it contains only one method - "CompareTo()" 

	Syntax - public int CompareTo(Object obj);
			 obj1.CompareTo(obj2);
				- Return -ve iff obj1 has come before obj2 (means obj1 1St position)
				- Return +ve iff obj1 has come after obj2 (means obj1 last position)
				- Return 0 iff obj1 & obj2 both are equal.
			Ex -         
				System.out.println("A".compareTo("Z"));  // -ve // -25
				System.out.println("Z".compareTo("K"));  // +ve // 15
				System.out.println("A".compareTo("A"));  // 0
				System.out.println("A".compareTo(null)); // NullPointerException
	
	- If you are depending on default natural sorting order then while adding object into the TreeSet JVM will call compareTo() method
	Diagram---------- (2.04.2025)

	NOTE - If "default natural sorting order" not available or if we are not satified with "default natural sorting order" then we can go for "Customizer Sorting" by using "Comaparetor".
		 -Comparable meant for "Default sorting Order"
		 -Comaparetor meant for "Customize Sorting Order".

***** Comaparetor
-----------------
	-Comaparetor present in java.util package and it define 2 method 
		1- public int compare(Object obj1, Object obj2); 
			- Return -ve iff obj1 has come before obj2 (means obj1 1St position)
			- Return +ve iff obj1 has come after obj2 (means obj1 last position)
			- Return 0 iff obj1 & obj2 both are equal.
		2- public boolean equal(Object obj);
	-When ever we are implementing Comaparetor interface complsure we should Implementation of only for compare method and we not provid Implementation of equal() because it is already available to our class from Object Class through inheritance
	EX - WAP to insert integer object into the TreeSet where the Sorting order is descending order
	Diagram (03.04.2025)----------


	NOTE - Tree are travale "Left - Node - Right".

	-At line if you are not passing comparator object then internally JVM will call compareTo() which is maint for default natural sorting order in this case the output is [0, 5, 10, 15, 20]
	-At line one if you are passing comparator object then JVM will call compare() which is maint for Customizer Sorting in this output is [20, 15, 10, 5, 0]
	
***** Various possible Implementation of Compare()
---------------------------------------------------
	- Integer i1 = (Integer) obj1;
	- Integer i2 = (Integer) obj2;

	- return i1.compareTo(i2); // [Ascending order] ---> [0, 5, 10, 15, 20]
	- return -i1.compareTo(i2); // [Descending order] ---> [20, 15, 10, 5, 0]
	- return i2.compareTo(i1); // [Descending order] ---> [20, 15, 10, 5, 0]
	- return -i2.compareTo(i1); // [Ascending order] ---> [0, 5, 10, 15, 20]
	- return +1; // [Insertion order] ---> [10, 0, 15, 5, 20, 20]
	- return -1; // [Reversed of Insertion order] ---> [20, 20, 5, 15, 0, 10]
	- return 0; // [Only first element will added remains all are duplicate] ---> [10]

Q) WAP to insert String object into the TreeSet where all element should be inserted according to Reversed of Alphabetic order?

		import java.util.Comparator;
		import java.util.TreeSet;

		public class TreeSetDemo5 {
		    public static void main(String[] args) {
		//        TreeSet t = new TreeSet(); // default order -->[GangaBhavani, RajaKumari, Ramulamma, Roja, ShobhaRani]
		        TreeSet t = new TreeSet(new MyComparator2());
		        t.add("Roja");
		        t.add("ShobhaRani");
		        t.add("RajaKumari");
		        t.add("GangaBhavani");
		        t.add("Ramulamma");
		        System.out.println(t);
		    }
		}

		class  MyComparator2 implements Comparator{
		
		    @Override
		    public int compare(Object obj1, Object obj2){
		        String s1 = (String) obj1;
		        String s2 = obj2.toString();
		//        return -s1.compareTo(s2); // [Descending order] ---> [ShobhaRani, Roja, Ramulamma, RajaKumari, GangaBhavani]
		        return s2.compareTo(s1); // [Descending order] ---> [ShobhaRani, Roja, Ramulamma, RajaKumari, GangaBhavani]
		    }
		
		}

Q) WAP to insert StringBuffer object into the TreeSet where Sorting order is Alphabetic order?
		import java.util.Comparator;
		import java.util.TreeSet;

		public class TreeSetDemo6 {
			public static void main(String[] args) {
				TreeSet t = new TreeSet(new MyComparator3());
				t.add(new StringBuffer("A"));
				t.add(new StringBuffer("Z"));
				t.add(new StringBuffer("K"));
				t.add(new StringBuffer("L"));
			
				System.out.println(t);
			}
		}

		class  MyComparator3 implements Comparator{

			@Override
			public int compare(Object obj1, Object obj2){
				String s1 = obj1.toString();
				String s2 = obj2.toString();
				return s1.compareTo(s2); // [Ascending Order] ---> [A, K, L, Z]
			}

		}

	NOTE - If we are depending on default natural sorting order complsure object should be homogeneous and comparable otherwise we wil get Run time Exception saying "classCastExecption".
		-If we are depending our own sort like comparator then object are need not be comparable and homogeneous i.e. we can add Heterogeneous non-Comparable object also.

Q) WAP to insert String and StringBuffer Object into TreeSet where sorting order is increasing length order, If 2 object having same length then consider they Alphabetical there order?

		import java.util.Comparator;
		import java.util.TreeSet;
			
		public class TreeSetDemo7 {
			public static void main(String[] args) {
		//		 TreeSet t = new TreeSet(); // Error --> ClassCastException
				TreeSet t = new TreeSet(new MyComparator4());
				t.add("A");
				t.add(new StringBuffer("ABC"));
				t.add(new StringBuffer("AA"));
				t.add("XX");
				t.add("ABCD");
				t.add("A");	
			
				System.out.println(t); // [A, AA, XX, ABC, ABCD]
			}
		}
		
		class  MyComparator4 implements Comparator{
				
			@Override
			public int compare(Object obj1, Object obj2){
				String s1 = obj1.toString();
				String s2 = obj2.toString();
				int l1 = s1.length();
				int l2 = s2.length();
			
				if (l1 < l2){
					return -1;
				}
				else if (l1 > l2){
					return  +1;
				}else {
					return s1.compareTo(s2); // if we return 0 ---> it will remove the same length String as duplicate then remove it // And it is also remove the same String.(like "A" & "A").
				}
			}
				
		}
		

***** Comparable VS Comaparetor
----------------------------------
		- For predefine Comparable classes default natural sorting order already available if we are not satified with that default natural sorting order then we can define our own sorting by using comparator.
		- For predefine non-comparable classes(Like StringBuffer) default natural sorting order not already available we can define our own sorting by using comparator.
		- For our own classes like Employee , the person who is writing the class is responsible to define default natural sorting order by implementing Comparable Interface.
		- The person who is using our class, If he is not satified with default natural sorting order then he can define his own sorting using comparator.
		Diagram --(04.04.2025)

***** Comparision of Comparable AND Comaparetor
------------------------------------------------
Comparable
-----------
		- It is maint for "default natural sorting order".
		- Present in "Java.lang package".
		- It defines only one method "compareTo()"
		- "String and all wrapper" class implement comparable interface.

Comaparetor
-----------
		- It is maint for "customized sorting order".
		- Present in "Java.util package".
		- It defines 2 method "compare() * equals()";
		- The only implemented classes of comparator are "collator & RuleBasedCollator".

***** Comparision table of Set implemented classes
---------------------------------------------------
Property
-----------
		- underline Data structur
		- Duplicate Object
		- Insertion order
		- Sorting Order
		- Heterogeneous Object
		- Null Accept
	
HashTable
-----------
		- HashTable	
		- Not Allowed
		- Not preserved
		- Not applicable
		- Allowed
		- Allowed

LinkedHashSet
--------------
		- LinkedList + HashTable
		- Not Allowed
		- preserved
		- Not applicable
		- Allowed
		- Allowed

TreeSet
--------
		- BalancedTree
		- Not Allowed
		- Not preserved
		- Applicable
		- Not Allowed
		- Allowed (For empty TreeSet first element allowed)

	NOTE - For empty TreeSet as the first element Null is allowed but this rule is applicable until 1.6v only from 1.7v ownword NULL is not allowed even if the first element.

***** Map
----------
		1-HashMap
		2-LinkedHashMap
		3-IdentityHashMap
		4-WeakHashMap
		5-SortedHashMap
		6-NavigableHashMap
		7-TreeMap
		8-Dictionary
		9-Hashtable
		10-Properties

		Diagram(09-04-2025)

		-Map is "not child interface of collection".
		-If we want represent a group of object as key-value pair then we should go for Map.
		Diagram (09-04-2025)
		-Both keys and values are objects only.
		-Duplicate keys are not allowed but values can be duplicated.
		-Each key-value pair is called entry  hence map is consider as , a collection of entry  objects.


		ALL method
		-----------
			Object put(Object key, Object value)
				-To add one key value pair to the map.
				-If the key is already present then old value will be replaceed with new value and returns old value.
				EX - m.put(101,"kanha");
				     m.put(102,"Pravu");
				     m.put(101,"Hero");
					 -> kanha got replaceed with Hero.

			void putAll()

			Object get(Object key)
				-returns the values associated with specified key.

			Object remove(Object key)
				-removes the entry associated with specified key.

			boolean containsKey(Object key)

			boolean containsValue(Object value)

			boolean isEmpty()

			int size()

			void clear();
				-All key value pair will be removed.

			Set keySet()
			Collection values()
			set entrySet()
				-The above 3 method are called as collection views of map.

*** Entry (I)
----------------
		-A map is a group of key value Pairs and each key value pair is called an entry hence map is consider as a collection of entry objects.
		-Without existing map object there is no chance of existing entry object hence entry interface is define inside map interface.
		Ex-
		interface  map{
			-------
			-------
			-------
		    interface  entry{
		        Object getKeys();                 |      
		        Object getValue();                | -> These 3 methods are entry specific methods and we can apply only on Entry Object
		        Object setValue(Object newValue); |
		    }
		}

***** HashMap
----------------
		-The underline data structure is HashTable.
		-Insertion order is not preserved and it is based on hashCode of keys.
		-Duplicate keys are anot allowed but values can be duplicated.
		-Heterogeneous Object are allowed for both key and value.
		-Null is allowed for key(Only once)
		-Null is allowed for values(Any number of time)
		-HashMap implement serializable and clonable interface but not RandomAccess.
		-HashMap is the best choice if our frequent operation is search operation.

		Constructor
		----------
			HashMap h = new HashMap()
				-Creates an empty HashMap object with default initialCapacity 16 and default fillRatio 0.75.

			HashMap h = new HashMap(int initialCapacity)
				-Creates an empty HashMap objects with specified initialCapacity and default fillRatio 0.75.

			HashMap h = new HashMap(int initialCapacity, float fillRatio)

			HashMap h = new HashMap(map m)

***** Difference between HashMap and HashTable
----------------------------------------------
HashMap
-------
		-Every method present in HashMap is Not-Synchronized
		-At a time multiple Thread are allowed to operate on HashMap object and hence it not thread safe.
		-Relatively performance is High because thread are not required to wait to operate on HashMap Object.
		-NULL is allowed for both key and value.
		-Introduced in 1.2v and it is not Legacy.

HashTable
---------
		-Every method present in HashMap is Synchronized
		-At a time only one Thread is allowed to operate on HashTable object and hence it thread safe.
		-Relatively performance is low because thread are required to wait to operate on HashTable object.
		-Null is not allowed for key and value otherwise we will get NullPointerException.
		-Introduced in 1.0v and it Legacy.


***** How to get Synchronized version of HashMap Object
---------------------------------------------------------
		-By default HashMap is Non-Synchronized but we can get Synchronized version of HashMap by using Synchronized Map Method of Collection Class.
		Ex -
		HashMap m = new HashMap();
		Map m1 = Collections.synchronizedMap(m);
		Note ----> m is not-Synchronized but m1 is Synchronized 

***** LinkedHashMap
----------------------
		-It is the child class of HashMap.
		-It is exactly same as HashMap(including methods and Constructors except the following difference)

		HashMap
		-------
			-The underline data structure is HashTable.
			-Insertion order is not preserved and it is based on hashCode of keys.
			-Introduced in 1.2v

		LinkedHashMap
		--------------
			-The underline data structure is the combination of LinkedList and HashTable(Hybrid data structure).
			-Insertion order is preserved.
			-Introduced in 1.4v

		EX-
		LinkedHashMap m = new LinkedHashMap();
        m.put("kanha",700);
        m.put("Pravu",500);
        m.put("Dibya",200);
        m.put("Danu",500);
        System.out.println(m); //{kanha=700, Pravu=500, Dibya=200, Danu=500}

		-In the above program say that in LinkedHashMap the Insertion order is preserved.

		NOTE --> LinkedHashSet and LinkedHashMap are commonlly used for developing cache based application.

***** Difference between == operator and .equals()
---------------------------------------------------
		-In general == operators maint for reference comparesion (Address Comparision) where as .equals() maint for content Comparision.
		Ex-
		// if i1 and i2 in the range of 1 to 127 then it will show true for all the case. 
        Integer i1 = 1200;
        Integer i2 = 1200;
        System.out.println(i1 == i2); // it return false because of it check the reference not value
        System.out.println(i1.equals(i2)); // it return true because of it check value not reference

***** IdentityHashMap
----------------------
		-It is exactly same as HashMap(including methods and Constructor ) except the following difference.
		-In the case of normal HashMap JVM will used .equals method to identify the duplicate key which is maint for content comparesion but in the case if IdentityHashMap JVM will used == operators to identify the Duplicate key which is maint for reference comparesion(Address comparesion).
		Ex -

		Integer i1 = 1222;
        Integer i2 = 1222;

        HashMap m = new HashMap(); // HashMap
        m.put(i1,"kanha");
        m.put(i2,"Pravu");
        System.out.println(m);	// {1222=Pravu}	

		-->i1 and i2 are duplicate key because i1.equals(i2) return true.
		-If we replace HashMap with IdentityHashMap Then i1 and i2 are not duplicate case because i1 == i2 return false.

		IdentityHashMap m = new IdentityHashMap(); // IdentityHashMap
        m.put(i1,"kanha");
        m.put(i2,"Pravu");
        System.out.println(m);	// {1222=Pravu, 1222=kanha}

***** WeakHashMap
------------------
		-It is exactly same as HashMap except the following difference.
		-In the case of HashMap eventhough Object doesnot have any reference it is not elisible for GC(garbeg Collector) if it is associated with HashMap i.e. HashMap dominate GC(garbeg Collector)
		-But in the case of WeakHashMap if object does not contain any reference it is elisible for GC(garbeg Collector) eventhough object associated with WeakHashMap i.e. GC(garbeg Collector) dominate WeakHashMap

		EX-
 		HashMap h = new HashMap();  //{temp=kanha} {temp=kanha}
        Temp t = new Temp(); // it is a BLC class , In this class 2 Method are Override these are toString() & finalize()
        h.put(t,"kanha");
        System.out.println(h);
        t = null;
        System.gc(); // To call Garbage collector to clean non-reference object
        Thread.sleep(3000);
        System.out.println(h);  

		-In the above example temp object not elisible for GC because it is associated with HashMap.
		-In this case Output is 
			-{temp=kanha}
			-{temp=kanha}

		EX-
        WeakHashMap h = new WeakHashMap();  //{temp=kanha} {}
        Temp t = new Temp(); // it is a BLC class , In this class 2 Method are Override these are toString() & finalize()
        h.put(t,"kanha");
        System.out.println(h);
        t = null;
        System.gc(); // To call Garbage collector to clean non-reference object
        Thread.sleep(3000);
        System.out.println(h);  

		-In the above program we replace HashMap with WeakHashMap Then temp object elisible for GC(garbeg Collector)
		-In this case output is 
			-{temp=kanha}
			-It Executed when Garbage Collectors Clean the temp Object
			-{} 

***** SortedMap
------------------
		-It is the child interface of Map.
		-If you want represent a group of key value pair according to some sorting order for key then we should go for SortedMap.
		-Sorting is based on the key but not based in value.
		-SortedMap defines the following specific methods.
		
		ALL method
		-----------
			-Object firstKey();
			-Object lastKey();
			-SortedMap headMap(Object key)
			-SortedMap tailMap(Object key)
			-SortedMap subMap(Object keyl,Object key2)
			-Comparator comparator()
		
		EX-
		101 -> A
        103 -> B
        104 -> C
        107 -> D
        125 -> E
        136 -> F

        firstKey() --> 101
        lastKey() --> 136
        headMap(107) --> {101=A,103=B,104=C}
        tailMap(107) --> {107=D,125=E,136=F}
        subMap(103,125) --> {103=B,104=C,107=D}
        comparator() --> null (due to default Ascending order apply then it return null)

***** TreeMap
---------------
		-The underline Data structure is RED-BLACK tree.
		-insertion Order is not preserved and it is based on some sorting order of Key.
		-Duplicate key are not allowed but values can be duplicated.
		-If we are depending on default natural sorting order then keys should be homogeneous and comparable otherwise we will get runtime exception saying classCastExecption.
		-If we are defining our own sorting by comparator then keys need not be homogeneous and comparable we can take Heterogeneous non-comparable object also.
		-Wheather we are deppending on default natural sorting order are costumizer sorting order there are no restrection for value we can take Heterogeneous non-comparable object also.

		*** Null Acceptance
		--------------------
			1-For non empty TreeMap if we are trying to insert an entry with null key then we will get runtime exception saying NullPointerException.
			2-For empty TreeMap at the first Entry with null key is allowed but after inserting that entry if we are trying to insert any other entry then we will get runtime exception saying NullPointerException.

			NOTE --> The above null Acceptance role applicable until 1.6v only from 1.7v on ownword Null is not allowed for key. but for value null used any of time there is no restrection Wheather it is 1.6v or 1.7v.

		Constructor
		------------
			-TreeMap t = new TreeMap()
				- For default natural sorting order.
			-TreeMap t = new TreeMap(Comaparetor c)
				- For customized sorting order.
			-TreeMap t = new TreeMap(SortedMap s)
			-TreeMap t = new TreeMap(Map m)

		Ex- of default natural sorting order
		TreeMap t = new TreeMap();
        t.put(100,"kanha");
        t.put(103,"ZZZ");
        t.put(101,"XXX");
        t.put(106,123);
		// t.put("FFFF","CCX"); // ClassCastException
		// t.put(null,"NPX"); //NullPointerException
        System.out.println(t); //{100=kanha, 101=XXX, 103=ZZZ, 106=123}

		Ex - For Customize sorting order
		public class CustomizedSortingOrderTreeMapDemo1 {
			public static void main(String[] args) {
				TreeMap t = new TreeMap(new MyComparator());
				t.put("AAA",123);
				t.put("XXX",456);
				t.put("LLL",789);
				t.put("ZZZ","kanha");
				System.out.println(t); //{ZZZ=kanha, XXX=456, LLL=789, AAA=123}
			}
		}
		class  MyComparator implements Comparator {
			@Override
			public int compare(Object obj1, Object obj2) {
				String str1 = (String) obj1;
				String str2 = (String) obj2;
				return str2.compareTo(str1);
			}
		}